{{- $grafana := index .Values "kube-prometheus-stack" "grafana" "enabled"|default false -}}
{{- if $grafana }}
apiVersion: v1
kind: ConfigMap
metadata:
  name: {{ .Release.Name }}-grafana-ds-updater
  namespace: {{ .Release.Namespace }}
data:
  update_dashboard.py: |
    import requests
    import json
    import os
    from datetime import datetime, timezone

    # Get Grafana API credentials from environment variables
    GRAFANA_URL = os.getenv("GRAFANA_URL")
    API_TOKEN = os.getenv("API_TOKEN")
    RELEASE_NAME = os.getenv("RELEASE_NAME", "").lower()

    headers = {
        "Authorization": f"Bearer {API_TOKEN}",
        "Content-Type": "application/json"
    }

    # Fetch all Grafana datasources
    response = requests.get(f"{GRAFANA_URL}/api/datasources", headers=headers)
    datasources = response.json() if response.status_code == 200 else []

    # Function to execute PromQL queries
    def execute_promql_query(promql_query, key, uid):
        query_url = f"{GRAFANA_URL}/api/datasources/proxy/uid/{uid}/api/v1/query?query={promql_query}"
        response = requests.get(query_url, headers=headers)
        if response.status_code == 200:
            results = response.json().get("data", {}).get("result", [])
            if results:
                return results[0]["metric"].get(key, "N/A")
        return "Error"

    # Function to evaluate pod readiness and return bullet
    def get_health_status(uid):
        total_query = "sum(kube_deployment_spec_replicas{namespace=\"monitoring\"})"
        ready_query = "sum(kube_deployment_status_replicas_ready{namespace=\"monitoring\"})"

        total = execute_promql_query(total_query, "", uid)
        ready = execute_promql_query(ready_query, "", uid)

        try:
            total_val = float(total[0]['value'][1]) if isinstance(total, list) else 0
            ready_val = float(ready[0]['value'][1]) if isinstance(ready, list) else 0

            if ready_val == 0:
                return ":red_circle:"
            elif ready_val < total_val:
                return ":large_yellow_circle:"
            else:
                return ":large_green_circle:"
        except:
            return ":grey_question:"

    # Collect data for each Prometheus datasource
    prometheus_versions = []

    for ds in datasources:
        if ds["type"] == "prometheus":
            uid = ds["uid"]
            prometheus_name = f"[ {ds['name']} ](/d/k8s_views_global/k8s-views-global?from=now-1h&to=now&var-datasource={uid}&var-cluster=&var-resolution=30s&var-job=node-exporter&refresh=30s)"
            kubernetes_version = execute_promql_query("kubernetes_build_info", "git_version", uid)
            prometheus_version = execute_promql_query("prometheus_build_info", "version", uid)
            loki_version = execute_promql_query("loki_build_info", "version", uid)
            promtail_version = execute_promql_query("promtail_build_info", "version", uid)
            health_status = get_health_status(uid)

            prometheus_versions.append([
                prometheus_name, kubernetes_version, prometheus_version, loki_version, promtail_version, health_status
            ])

    # Get current timestamp and version tag
    timestamp = datetime.now(timezone.utc).strftime("%Y-%m-%d %H:%M UTC")
    version_tag = datetime.now(timezone.utc).strftime("v%Y%m%d-%H%M")

    # Convert data to table format for Grafana dashboard
    header = f"_Last updated: {timestamp}_\n\n"
    table_content = "| Prometheus Datasource | Kubernetes Version | Prometheus Version | Loki Version | Promtail Version | Status |\n"
    table_content += "|----------------------|--------------------|--------------------|--------------|------------------|--------|\n"
    for row in prometheus_versions:
        table_content += f"| {row[0]} | {row[1]} | {row[2]} | {row[3]} | {row[4]} | {row[5]} |\n"

    footer = f"\n\n_Last updated: {timestamp}_"
    footer += "\n\n[**Grafana Home**](/)"

    # Combine full markdown content
    full_markdown = header + table_content + footer

    # Create a Grafana dashboard JSON object
    dashboard_json = {
        "apiVersion": "v1",
        "kind": "ConfigMap",
        "metadata": {
            "name": "{{ .Release.Name }}-grafana-dashboards-crisp-maindash",
            "labels": {"grafana_dashboard": "1"}
        },
        "data": {
            "crisp-maindash.json": json.dumps({
                "id": None,
                "uid": "crisp-maindash",
                "title": "Clusters List - Main Dashboard",
                "tags": ["CRISP DevOps", "Generated by automation", version_tag],
                "timezone": "browser",
                "schemaVersion": 16,
                "version": 1,
                "refresh": "5m",
                "time": {
                    "from": "now-5m",
                    "to": "now"
                },
                "panels": [
                    {
                        "type": "text",
                        "title": "Prometheus Versions Overview",
                        "gridPos": {"x": 0, "y": 0, "w": 24, "h": 24},
                        "mode": "markdown",
                        "content": full_markdown
                    }
                ]
            }, indent=2)
        }
    }

    # Ensure the directory exists
    configmap_dir = "/script-tmp"
    os.makedirs(configmap_dir, exist_ok=True)

    # Save as ConfigMap YAML file
    configmap_path = os.path.join(configmap_dir, "crisp-maindash.yaml")
    with open(configmap_path, "w") as f:
        json.dump(dashboard_json, f, indent=2)

    # Apply the updated ConfigMap to Kubernetes
    os.system(f"kubectl apply -f {configmap_path}")
{{- end }}